<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Paul Lewis" />
  <meta name="viewport" content="width=device-width">
  <title></title>
  <style>
    html, body {
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
<canvas id="canvas1" width="2000" height="2000" style = "border: 1px solid black;"></canvas>
<script>
var can = document.getElementById('canvas1');
var ctx = can.getContext('2d');
can.tabIndex = 1; // quick way to get focus so keypresses register
ctx.font = '16px sans';

var thingsOnMap = [
    [50,50],
    [55,70],
    [15,22],
    [150,20],
    [120,80],
    [100,10],
    [170,40],
    [130,70],
    [230,10],
    [330,45],
    [250,65]
];

// player's position
var playerX = 20;
var playerY = 20;

// how far offset the canvas is
var offsetX = 0;
var offsetY = 0;
    
function draw() {
    ctx.save();
    ctx.translate(offsetX, offsetY);
    // clear the viewport
    ctx.clearRect(-offsetX, -offsetY, 100,100);
    
    // draw the player
    ctx.fillStyle = 'red';
    ctx.fillRect(playerX-offsetX, playerY-offsetY, 8, 8);
    
    // draw the other stuff
    var l = thingsOnMap.length;
    for (var i = 0; i < l; i++) {
        // we should really only draw the things that intersect the viewport!
        // but I am lazy so we are drawing everything here
        var x = thingsOnMap[i][0];
        var y = thingsOnMap[i][1];
        ctx.fillStyle = 'lightblue';
        ctx.fillRect(x, y, 8, 8);
        ctx.fillStyle = 'black';
        ctx.fillText(x + ', ' + y, x, y) // just to show where we are drawing these things
    }
    
    ctx.restore();
}
    
can.addEventListener('keydown', function(e) {
    console.log('here');
    if (e.keyCode === 37) { // left
	offsetX++;
    } else if (e.keyCode === 39) { // right
	offsetX--;
    }
    draw();
}, false);


draw();


//stackoverflow
function pad(n, width, z) {
    z = z || '0';
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}


let arrayWidth = 5;
function load() {
    let imageArray = [];
    for(var i = 0; i < 24; i++) {
        var imageObj = new Image();
	console.log('here',i);
        imageObj.onload = (function(pos) {
	    return function() {
		console.log(pos,pos%arrayWidth,(pos%arrayWidth)*this.width,Math.floor(pos/arrayWidth)*this.height);
	        ctx.drawImage(this, this.width*(pos%arrayWidth), Math.floor(pos/arrayWidth)*this.height);
	    }
        })(i);
        imageObj.src = `tiles/tile${pad(i,3)}.png`;
    }
}
load();

function setup(){
    // populate your imageArray with the image tiles

    // Now call requestAmimationFrame
    window.requestAnimationFrame(myRenderTileSetup);
}
function myRenderTileSetup(){ // this renders the tiles as they are avalible
    var renderedCount = 0;
    for(y = 0; y < tilesHeight; y+=1 ){
        for(x = 0; x < tilesWidth; x+=1 ){
            arrayIndex = x+y*tilesWidth;
            // check if the image is available and loaded.
            if(imageArray[arrayIndex] && imageArray[arrayIndex].complete){
                 //backGroundCTX.drawImage(imageArray[arrayIndex],... // draw the image
                 imageArray[arrayIndex] = undefined; // we dont need the image
                                                     // so unreference it
            }else{  // the image is not there so must have been rendered
                 renderedCount += 1;  // count rendered tiles.
            }
        }
     }
     // when all tiles have been loaded and rendered switch to the game render function
     if(renderedCount === tilesWidth*tilesHeight){
          // background completely rendered
          // switch rendering to the main game render.
          window.requestAnimationFrame(myRenderMain);
     }else{
          // if not all available keep doing this till all tiles complete/ 
          window.requestAnimationFrame(myRenderTileSetup);
     }
}

function myRenderMain(){
    // render the background tiles canvas
    // render game graphics.
    // now ready for next frame.
    window.requestAnimationFrame(myRenderMain);
}
</script>

</body>
</html>
